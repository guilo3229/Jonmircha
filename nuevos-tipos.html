<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nuevos tipos de Datos en Javascript</title>
</head>
<h1>Nuevos Tipos De Datos en Javascript</h1>
<body>

   <script> 
console.log(this)
console.log(window)
console.log(this === window)

this.nombre = "Contexto Global"
console.log(this.nombre)
function imprimir(){
   console.log(this.nombre)
}
imprimir()
{

   // Esto es un bloque
}
const obj = {
   nombre: "contexto Objeto",
   imprimir: function(){
      console.log(this.nombre)
   }
}

obj.imprimir()
const obj2 = {
   nombre: "Contexto Objeto 2",
   imprimir
}
obj2.imprimir()

const obj3 = {
   nombre: "contexto Objeto3",
   imprimir: ()=>{
      // Las arrow function cogen la propiedad this del ambito global, es decir del objeto window si no esta, saldra undefined aunque este en las pro`piedades dentro del mismo objeto. como objeto 3 fue creado en el concepto global
      console.log(this.nombre)
   }
}
obj3.imprimir()
// esto es una funcion constructora que crea su propio SCOPE
function Persona(nombre){
   this.nombre = nombre;
   // return console.log(this.nombre)
   // creamos una funcion anonima, en el return y le ponemos el console.log(this.nombre)
   // return function (){
   //    // como esta funcion anonima no tiene el contexto nombre regresa al scope global y no al scope de la funcion predecesora, para evitar eso usaremos una arrow function que esta si que coge el mas inmediato scope.

   //    console.log(this.nombre, 22)
   // }
   return() => console.log(this.nombre)
}
let jon = new Persona("Jon")
jon()

function Persona2(nombre){
   // that va a hacer referencia al this de la funcion constructora(esto antiguamente ya nos e usa)
   const that = this;
   // this.nombre = nombre;
that.nombre = nombre
   return function (){
      console.log(that.nombre)
   }
}
let federico = new Persona2("Federico")
federico()
   </script> 
</body>
</html>